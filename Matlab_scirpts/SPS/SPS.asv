classdef SPS
    properties
        p      % Confidence probability
        m      % Integer m such that p = 1 − q/m
        q      % Integer q such that p = 1 − q/m
        n      % Number of data points
        alpha  % Random signs
        pi     % Random permutation
    end
    
    methods
        function obj = SPS(p, m, q, n)
            % Constructor to initialize the SPS parameters
            obj.p = p;
            obj.m = m;
            obj.q = q;
            obj.n = n;
        end
        
        function obj = generateRandomSignsAndPermutation(obj)
            % Generate and return random signs and permutation
             % Generate random signs
            obj.alpha = randi([0, 1], obj.m-1, obj.n) * 2 - 1; % Random signs {-1, 1}
            % Generate a random permutation
            obj.pi = randperm(obj.m);
        end
        
        function theta_hat = leastSquaresEstimator(~, X, y)
            % Least Squares Estimator
            % X - Design matrix
            % y - Output vector
            
            % Ensure X is full rank for least squares estimation
            if rank(X) < size(X, 2)
                error('Design matrix X is rank deficient.');
            end
            
            % Compute least squares estimate
            theta_hat = (X' * X) \ (X' * y);
        end
        
        function [theta_hat] = estimateParameters(obj, X, y)
            % Estimate parameters using least squares
            % X - Design matrix
            % y - Output vector
            
            % Check if design matrix X and output vector y are valid
            if size(X, 1) ~= length(y)
                error('Design matrix X and output vector y must have the same number of rows.');
            end
            
            % Compute parameter estimates
            theta_hat = obj.leastSquaresEstimator(X, y);
        end
        
        function y_pred = predictor(~, X, theta_hat)
            % Predictor to compute predicted values using estimated parameters
            % X - Design matrix for prediction
            % theta_hat - Estimated parameters
            
            % Ensure that the design matrix X has the same number of columns as theta_hat
            if size(X, 2) ~= length(theta_hat)
                error('Design matrix X and estimated parameters theta_hat have incompatible dimensions.');
            end
            
            % Compute the predicted values
            y_pred = X * theta_hat;
        end
        
        function is_in_conf_region = sps_indicator(obj, X, y, theta_hat)
            % Make predictions with new data
            y_pred = sps.predictor(X, theta_hat);
            % PE
            y_errors = y-y_pred;
            % build m-1 sequences of sign perturbed prediction errors
            sp_errors = obj.alpha.*y_errors';

            A_star = [1, theta_hat(1)];
            B_star = [theta_hat(2)];
            C_star = [1];
            D_star = 0;

            % Create an instance of ARMAXGenerator
            armaxGen_bar = ARMAXGenerator(A_star, B_star, C_star, D_star, @custom_past_y);

            y_bar = zeros(m, n);
            u_bar = zeros(m, n);
            x_size = size(X);
            S = zeros(1,m);

            y_bar(1,:) = y;
            u_bar(1,:) = u;
            X_bar = X;

            R = X' * X / n;
            S(1) = norm(R^(-1/2) * X'*sp_errors(1,:)');


            for k = 2:m 
                [y_bar(k,:), u_bar(k,:), ~] = armaxGen.generateData(n,sp_errors(k-1,:)');
                X_bar =  createFeatureMatrix(y_bar(k,:),u_bar(k,:));
                R =  X_bar'* X_bar /n;
                S(k) = norm(R^(-1/2) * X_bar'*sp_errors(k-1,:)');
                %armaxGen.plotData(y_bar(k,:), u_bar(k,:), sp_errors(k,:)');
            end

            % Combine S and Pi into a matrix

            SP = [S(:), sps.pi(:)];

            % Sort SM based on S with Pi as a tiebreaker and keep track of original indices
            [a, sort_order] = sortrows(SP, [1, 2]);

            % Find the new index of the first element of the original S
            new_index = find(sort_order == 1);

            new_index<=m-q



            
        end
        
    end
end
